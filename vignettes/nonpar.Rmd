---
title: "Non-parametric Inference of Fi-values"
output: html_document
---

<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>


<head>
<script>
function showModal(imageUrl) {
  var modal = document.getElementById("myModal");
  var modalImg = document.getElementById("img01");
  modal.style.display = "block";
  modalImg.src = imageUrl;
}

// When the user clicks anywhere outside of the modal, close it
window.onclick = function(event) {
  var modal = document.getElementById("myModal");
  if (event.target == modal) {
    modal.style.display = "none";
  }
}
</script>
<style>
/* Modal styles here */
</style>
</head>
<body>

<div id="myModal" class="modal">
  <span class="close">&times;</span>
  <img class="modal-content" id="img01">
</div>

<style>
.grid-container {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); /* Adjust the minmax for your grid item size */
  gap: 10px; /* Adjust the gap size as needed */
  padding: 10px;
}

.grid-item {
  background-color: #f0f0f0; /* Grid item background color */
  border: 1px solid #ccc; /* Grid item border */
  padding: 10px;
  text-align: center;
}
</style>

```{r setup, include=FALSE, message=FALSE}
root <- rprojroot::find_root(rprojroot::has_dir(".git"))
r_dir <- file.path(root, "r")
invisible(lapply(list.files(r_dir, full.names = TRUE, recursive = TRUE),
                 source))
cpp_dir <- file.path(root, "cpp")
invisible(lapply(list.files(cpp_dir, full.names = TRUE), sourceCpp))
tex <- latex2exp::TeX

# set the seed
set.seed(2023)

# load data
dat_lst <- real_data()
k <- 5
R <- dat_lst$R[, seq_len(k)]
X <- dat_lst$X
Y <- dat_lst$Y

nboot <- 50
fi_seq <- c(seq(0, 0.2, 0.05))
```

## Agnostic $\phi$-values

We first explore agnostic $\phi$-values, meaning that the missingness pattern $\Phi = (\phi, \phi, \phi, \phi)$. We allow $\phi$ to vary within the sequence `r fi_seq`. 

```{r main, fig.align='center'}
sns <- axis_search(X, Y, R, fi_seq, "agnostic", "backward", "ATE")
df <- sns[["df"]]

p_agnostic <- ggplot(df, aes(x = fi, y = val)) +
    geom_line() + geom_point() +
    xlab(tex("$\\phi$ value")) +
    ylab("ATE") +
    theme_minimal() +
    scale_y_continuous(labels = scales::percent)
```

```{r, echo=FALSE}
ggsave(file.path("plots", "nonpar-agnostic.png"), plot = p_agnostic, 
       width = 6, height = 4)
```

As noted in the manuscript, sometimes the missingness pattern $\Phi = (\phi, \phi, \phi, \phi)$ may yield $\hat p_{z \mid xy}$ estimates that have negative entries. For avoiding this, a gradient descent method is used to find the closest missingness pattern $\Phi$ for which this is not the case. Therefore, even though we set $\Phi = (\phi, \phi, \phi, \phi)$, the effective $\Phi$ that is used may differ somewhat, if the original inverse problem is ill-posed. Crucially, it is important to report the effective $\Phi$ profile.

### Agnostic Profiles

In the below list, the effective $\Phi$ values are given for each input value of $\phi$.

<ul>
```{r profiles, fig.align='center', results='asis', echo=FALSE}
plot_dir <- "plots"
if (!dir.exists("plots")) dir.create(plot_dir)

# Iterate over fi_seq and save plots
for (fi in fi_seq) {
  
  prof_idx <- which(fi_seq == fi)
  plot_file <- sprintf("%s/plot_%s.png", plot_dir, fi)
  
  # Create and save the plot
  p <- fi_prof(sns$res[[prof_idx]]$fi) + 
    ggtitle(tex(paste("Profile for $\\phi=$", fi)))
  ggsave(plot_file, plot = p, width = 6, height = 4)
  
  # Print clickable link
  cat(sprintf('<li><a href="javascript:showModal(\'%s\');">Profile for value %s</a></li>', plot_file, fi))

}
```
</ul>

## $x$-specific $\phi$-values

We next investigate possible $x$-specific $\phi$-values, for which the missingness $\Phi$ has the form $\Phi = (\phi_{x_0}, \phi_{x_1},\phi_{x_0},\phi_{x_1})$. 

```{r x-grid, fig.align='center'}
fi_grid <- rng_to_df("x", fi_seq, fi_seq)

fi_grid <- grid_search(fi_grid, "backward")
grid_to_plt(fi_grid, "backward", "x")
```

```{r x-grid-save, echo=FALSE}
ggsave(file.path("plots", "nonpar-x.png"), 
       width = 6, height = 4)
```

### $x$-specific Profiles

```{r profiles-grid, fig.align='center', results='asis', echo=FALSE}
plot_dir <- "plots"
if (!dir.exists("plots")) dir.create(plot_dir)

cat(paste0("<style>
.grid-container {
  display: grid;
  grid-template-columns: repeat(", length(fi_seq), ", 1fr);
  gap: 10px;
  padding: 10px;
}
.grid-item {
  background-color: #f0f0f0;
  border: 1px solid #ccc;
  padding: 10px;
  text-align: center;
}
</style>"))

# Begin grid container
cat("<div class='grid-container'>")

cool_ord <- order(fi_grid$fi_x0y1, fi_grid$fi_x1y0, 
                  decreasing = c(FALSE, TRUE))

# Double for loop to iterate over fi_seq
for (i in cool_ord) {
  
  fi_x0 <- fi_grid$fi_x0y0[i]
  fi_x1 <- fi_grid$fi_x1y0[i]
  prof_idx_x <- which(fi_seq == fi_x0)
  prof_idx_y <- which(fi_seq == fi_x1)
  plot_file <- sprintf("%s/plotX_%sx%s.png", plot_dir, fi_x0, fi_x1)

  # Create and save the plot
  p <- fi_prof(attr(fi_grid, "prof")[[i]]) + 
      ggtitle(tex(
        paste("Profile for $\\phi_{x_0}=$", fi_x0, " $\\phi_{x_1}=$", fi_x1)
      ))
  ggsave(plot_file, plot = p, width = 6, height = 4)

  # Print clickable grid item
  cat(sprintf("<div class='grid-item'><a href='javascript:showModal(\"%s\");'>Profile for \\(\\phi_{x_0} = %s\\), \\(\\phi_{x_1} = %s\\)</a></div>", plot_file, fi_x0, fi_x1))

}

# End grid container
cat("</div>")
```

## $y$-specific $\phi$-values

Finally, we investigate possible $y$-specific $\phi$-values, for which the missingness $\Phi$ has the form $\Phi = (\phi_{y_0}, \phi_{y_0},\phi_{y_1},\phi_{y_1})$. 

```{r y-grid, fig.align='center'}
yfi_grid <- rng_to_df("y", fi_seq, fi_seq)

yfi_grid <- grid_search(yfi_grid, "backward")
grid_to_plt(yfi_grid, "backward", "y")
```

```{r y-grid-save, echo=FALSE}
ggsave(file.path("plots", "nonpar-y.png"), 
       width = 6, height = 4)
```

### $y$-specific Profiles

```{r y-profiles-grid, fig.align='center', results='asis', echo=FALSE}
plot_dir <- "plots"
if (!dir.exists("plots")) dir.create(plot_dir)

# Begin grid container
cat("<div class='grid-container'>")

cool_ord <- order(yfi_grid$fi_x0y0, yfi_grid$fi_x0y1, 
                  decreasing = c(FALSE, TRUE))

# Double for loop to iterate over fi_seq
for (i in cool_ord) {
  
  fi_y0 <- yfi_grid$fi_x0y0[i]
  fi_y1 <- yfi_grid$fi_x0y1[i]
  prof_idx_x <- which(fi_seq == fi_y0)
  prof_idx_y <- which(fi_seq == fi_y1)
  plot_file <- sprintf("%s/plotY_%sx%s.png", plot_dir, fi_y0, fi_y1)

  # Create and save the plot
  p <- fi_prof(attr(yfi_grid, "prof")[[i]]) + 
      ggtitle(tex(
        paste("Profile for $\\phi_{y_0}=$", fi_y0, " $\\phi_{y_1}=$", fi_y1)
      ))
  ggsave(plot_file, plot = p, width = 6, height = 4)

  # Print clickable grid item
  cat(sprintf("<div class='grid-item'><a href='javascript:showModal(\"%s\");'>Profile for \\(\\phi_{y_0} = %s\\), \\(\\phi_{y_1} = %s\\)</a></div>", plot_file, fi_y0, fi_y1))

}

# End grid container
cat("</div>")
```


## $x$-specific $\phi$-values with Confidence Intervals

As the above results demonstrate, the most likely $\phi$-value is $x$-specific, with $\phi_{x_0}$ increasing and $\phi_{x_1}$ fixed. We first perform estimation of the ATE along this direction over multiple bootstrap repetitions.

```{r, axis-search-ci, fig.align='center', , fig.cap="Estimation of the ATE based on the non-parametric approach, x-specific in the direction of increasing missingness for X = 0."}
fi_seq <- subset(fi_grid, type == "x" & fi_x1y1 == 0)$fi_x0y1

axs_dat <- axis_search(X, Y, R, fi_seq, type = "x", solver = "backward",
                       nboot = nboot)[["df"]]

ggplot(axs_dat, aes(x = fi, y = mid)) +
  geom_point() + geom_line() +
  geom_ribbon(aes(ymin = lwr, ymax = upr), alpha = 0.3) +
  theme_bw() +
  xlab(tex("$\\phi_{x_1}")) +
  ylab(tex("ATE$_{x_0, x_1}(y ; \\Phi = (\\phi_{x_0}, 0, \\phi_{x_0}, 0))$"))
```

```{r x-axis-ci, echo=FALSE}
ggsave(file.path("plots", "nonpar-x-axis-ci.png"), 
       width = 6, height = 4)
```

In the final part of the experiment, we establish whether our inference method can be trusted, by applying it to a model with a known ground truth.


## Verification on a Known Ground Truth

We now investigate the performance of our inference method applied to data from a known ground truth model. In particular, we first assume that our data comes from an exponential family described in the manuscript (Eqs.~15-17), and we infer the parameters of this model assuming that $\Phi = (0, 0, 0, 0)$ is the true value (i.e., there is no data missingness). The matrix $\Sigma$ is estimated first: 

```{r infer-Sigma}
# infer the Sigma assuming \Phi = (0, 0, 0, 0)
Sigma_mim0 <- infer_Sigma(X, Y, R, fi = list(list(0, 0), list(0, 0)))
```

Then, we further infer the coefficients of $Z \to X$ (labeled $\lambda$), $Z \to Y$ (labeled $\mu$) again assuming $\Phi = (0, 0, 0, 0)$ is the true value. 

```{r infer-lambda-mu}
# infer the Z coefficients at X, Y
lambda <- glm(X ~ ., data = data.frame(X, R), family = "binomial")$coef
mu <- glm(Y ~ ., data = data.frame(Y, X, R), family = "binomial")$coef[-2]
mu_mod <- glm(Y ~ ., data = data.frame(Y, X, R), family = "binomial")
```

Now, for each value of $(\phi_{x_1}, \phi_{x_0})$ with $\phi_{x_0} \in \{0, 0.05, 0.1, 0.15, 0.2\}$ and $\phi_{x_1} = 0$, we pick the value of $\beta(\phi_{x_1}, \phi_{x_0})$ that generates exactly the same ATE as was obtained for $\text{ATE}_{x_0, x_1}(y \mid \Phi = (\phi_{x_0}, \phi_{x_1},\phi_{x_0},\phi_{x_1}))$.

```{r search-beta}
ate_to_or <- function(ate, mu_mod, R) {
  
  logits <- predict(mu_mod, data.frame(X = 0, R))
  
  a <- -0.5
  b <- 0.5
  while (b - a > 0.0005) {
    
    beta <- (b+a) / 2
    ate_b <- mean(expit(logits + beta) - expit(logits))
    
    if (ate_b > ate) b <- beta else a <- beta
  }
  
  (b+a) / 2
}
```

```{r x-axis-search}
fi_seq <- subset(fi_grid, type == "x" & fi_x1y1 == 0)$fi_x0y1
ate_seq <- subset(fi_grid, type == "x" & fi_x1y1 == 0)$ate

ate_seq <- ate_seq[order(fi_seq)]
fi_seq <- fi_seq[order(fi_seq)]

Xsim <- Ysim <- Rsim <- list()
for (i in seq_along(fi_seq)) {
  
  dat_sim <- synth_data_mid(
        n = nrow(R), k = nrow(Sigma_mim0),
        fi = list(list(fi_seq[i], fi_seq[i]), list(0, 0)),
        class = "expfam-2d",
        Sigma = Sigma_mim0, lam = lambda[-1], mu = mu[-1],
        icept_x = lambda[1], icept_y = mu[1],
        beta = ate_to_or(ate_seq[i], mu_mod, R)
      )
  
  Xsim[[i]] <- dat_sim$X
  Ysim[[i]] <- dat_sim$Y
  Rsim[[i]] <- dat_sim$R
}

plot_dat <- axis_search(Xsim, Ysim, Rsim, fi_seq, "x", "backward",
                        nboot = nboot)[["df"]]
```


Finally, after performing inference with a known ground truth, we can check the correctness.

```{r check-correctness, fig.align='center', fig.cap="Estimation of the ATE based on the non-parametric approach, x-specific in the direction of increasing missingness for X = 0, for a model with a known ground truth.", echo=FALSE}
# get the ground truth
df <- data.frame(fi = fi_seq, smooth = ate_seq)

# check the correctness of inference
ggplot(plot_dat, aes(x = fi, y = mid)) +
  geom_line(aes(color = "Estimated")) + 
  geom_point(aes(color = "Estimated")) +
  geom_ribbon(aes(ymin = lwr, ymax = upr),
              linewidth = 0, alpha = 0.2) +
  geom_hline(yintercept = 0, color = "red", 
             linetype = "dotdash", linewidth = 0.75) +
  theme_minimal() +
  geom_point(data = df, aes(x = fi, y = smooth, color = "Ground Truth")) +
  geom_line(data = df, aes(x = fi, y = smooth, color = "Ground Truth")) +
  scale_color_manual(
    name = "Quantity",
    values = c("black", "red"), 
    labels = c("Estimated", "Ground Truth")
  ) +
  theme(legend.position = "bottom") +
  xlab(tex("$\\phi_{x_1}")) +
  ylab(tex("ATE$_{x_0, x_1}(y ; \\Phi = (\\phi_{x_0}, 0, \\phi_{x_0}, 0))$"))

ggsave(file.path("plots", "nonpar-ground-truth.png"), 
       width = 6, height = 4)
```

The shaded area represents the 95\% confidence intervals obtained using bootstrap. As can be seen, our method performs reasonably well in capturing the ground truth effect estimates at different values of $\Phi$.